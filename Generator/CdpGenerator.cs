using Generator.Models;
using System.Security;
using System.Text;

namespace Generator
{
    public class CdpGenerator
    {
        public static string GenerateCode(Domain domain)
        {
            FixProtocolSpec(domain);

            return GenerateDomain(domain);
        }

        protected static void FixProtocolSpec(Domain domain)
        {
            //    Fixes following errors in the official CDP spec:
            // 1. DOM includes an erroneous $ref that refers to itself.
            // 2. Page includes an event with an extraneous backtick in the description.
            // 3. Network.Cookie.expires is optional because sometimes its value can be null.

            if (domain.Name == "DOM")
            {
                foreach (var _cmd in domain.Commands ?? new())
                {
                    if (_cmd.Name == "resolveNode")
                    {
                        // Patch 1
                        if (_cmd.Parameters != null)
                            _cmd.Parameters[1].Ref = "BackendNodeId";
                        break;
                    }
                }
            }
            else if (domain.Name == "Page")
            {
                foreach (var _event in domain.Events ?? new())
                {
                    if (_event.Name == "screencastVisibilityChanged")
                    {
                        // Patch 2
                        if (_event.Description != null)
                            _event.Description = _event.Description.Replace("`", "");
                        break;
                    }
                }
            }
            else if (domain.Name == "Network")
            {
                foreach (var _type in domain.Types ?? new())
                {
                    if (_type.Id == "Cookie")
                    {
                        foreach (var _prop in _type.Properties ?? new())
                        {
                            if (_prop.Name == "expires")
                            {
                                _prop.Optional = true;
                                break;
                            }
                        }
                    }
                }
            }
        }

        protected static string GenerateDomain(Domain domain)
        {
            var sb = new StringBuilder();
            var @namespace = "NoDriver.Cdp";

            // Header
            sb.AppendLine("// <auto-generated />");
            sb.AppendLine("using System;");
            sb.AppendLine("using System.Collections.Generic;");
            sb.AppendLine("using System.Text.Json.Serialization;");
            sb.AppendLine("using System.Threading.Tasks;");
            sb.AppendLine();
            sb.AppendLine($"namespace {@namespace}");
            sb.AppendLine("{");

            sb.AppendLine($"    public static partial class {domain.Name}");
            sb.AppendLine("    {");

            foreach (var type in domain.Types ?? new())
            {
                GenerateType(sb, type, domain.Name);
            }

            foreach (var cmd in domain.Commands ?? new())
            {
                GenerateCommand(sb, cmd, domain.Name);
            }

            foreach (var evt in domain.Events ?? new())
            {
                GenerateEvent(sb, evt, domain.Name);
            }

            sb.AppendLine("    }");
            sb.AppendLine("}");

            return sb.ToString();
        }

        protected static void GenerateType(StringBuilder sb, Models.Type type, string domainName)
        {
            if (type.Description != null)
                sb.Append(FormatDoc(type.Description, 1));

            // 處理 Enum
            //if (type.Enum != null && type.Enum.Count > 0)
            //{
            //    sb.AppendLine("    [System.Text.Json.Serialization.JsonConverter(typeof(System.Text.Json.Serialization.JsonStringEnumConverter))]");
            //    sb.AppendLine($"    public enum {typeName}");
            //    sb.AppendLine("    {");
            //    foreach (var val in type.Enum)
            //    {
            //        var name = ToPascalCase(val);
            //        if (char.IsDigit(name[0])) name = "_" + name;
            //        sb.AppendLine($"      [System.Text.Json.Serialization.JsonPropertyName(\"{val}\")] {name},");
            //    }
            //    sb.AppendLine("    }");
            //    return;
            //}

            // 不是 Object 也不是 Array 的型別，也就是字串、整數、布林值等基本型別
            if (type.Kind != TypeKind.Object && type.Kind != TypeKind.Array)
            {
                var valueType = GetCSharpBaseType(type.Kind);
                sb.AppendLine($"    [System.Text.Json.Serialization.JsonConverter(typeof(ChromeProtocol.Core.PrimitiveTypeConverter))]");
                sb.AppendLine($"    public record {type.Id}(");
                sb.AppendLine($"      {valueType} Value");
                sb.AppendLine($"    ) : ChromeProtocol.Core.PrimitiveType<{valueType}>(Value)");
                sb.AppendLine("    {");
                sb.AppendLine("    }");
            }
            // 型別是 Object，但沒有定義任何屬性
            else if (type.Kind == TypeKind.Object && (type.Properties == null || type.Properties.Count == 0))
            {
                sb.AppendLine($"    [System.Text.Json.Serialization.JsonConverter(typeof(ChromeProtocol.Core.ObjectTypeConverter))]");
                sb.AppendLine($"    public record {type.Id}(");
                sb.AppendLine($"      System.Collections.Generic.IReadOnlyDictionary<string, System.Text.Json.Nodes.JsonNode?> Properties");
                sb.AppendLine($"    ) : ChromeProtocol.Core.IObjectType");
                sb.AppendLine("    {");
                sb.AppendLine("    }");
            }
            // 型別是陣列 Array
            else if (type.Kind == TypeKind.Array)
            {
                // 這裡的 Items 來自 CDP spec 定義
                var itemsType = "System.Text.Json.Nodes.JsonNode";
                if (type.Items != null)
                {
                    itemsType = GetCSharpType(type.Items.Type, type.Items.Ref, null, domainName);
                }

                sb.AppendLine($"    [System.Text.Json.Serialization.JsonConverter(typeof(ChromeProtocol.Core.ArrayTypeConverter))]");
                sb.AppendLine($"    public record {type.Id}(");
                sb.AppendLine($"      System.Collections.Generic.IReadOnlyCollection<{itemsType}> Items");
                sb.AppendLine($"    ) : ChromeProtocol.Core.IArrayType");
                sb.AppendLine("    {");
                sb.AppendLine("    }");
            }
            // 有定義具體屬性的物件 TypeKind.Object 且 Properties.Length > 0
            else
            {
                sb.AppendLine($"    public record {type.Id}(");
                GeneratePropertiesList(sb, type.Properties, domainName, 3);
                sb.AppendLine($"    ) : ChromeProtocol.Core.IType");
                sb.AppendLine("    {");
                sb.AppendLine("    }");
            }
        }

        protected static void GenerateCommand(StringBuilder sb, Command command, string domainName)
        {
            if (command.Description != null)
                sb.Append(FormatDoc(command.Description, 2));

            if (command.Deprecated == true)
                sb.AppendLine("        [Obsolete]");

            var methodName = ToPascalCase(command.Name);
            var reqName = $"{methodName}Request";
            var resName = $"{reqName}Result";

            // --- 1. Static Helper Method ---
            if (command.Description != null)
                sb.Append(FormatDoc(command.Description, 2, command.Parameters));

            var methodArgs = new List<string>();
            var constructorArgs = new List<string>();

            foreach (var p in command.Parameters ?? new())
            {
                var csharpType = GetCSharpType(p.Type, p.Ref, p.Items, domainName);
                var argName = EscapeKeyword(ToPascalCase(p.Name));

                if (p.Optional == true)
                    methodArgs.Add($"{csharpType}? {argName} = default");
                else
                    methodArgs.Add($"{csharpType} {argName}");

                constructorArgs.Add(argName);
            }

            sb.AppendLine($"    public static ChromeProtocol.Domains.{domainName}.{reqName} {methodName}({string.Join(", ", methodArgs)})    ");
            sb.AppendLine("    {");
            sb.AppendLine($"      return new ChromeProtocol.Domains.{domainName}.{reqName}({string.Join(", ", constructorArgs)});");
            sb.AppendLine("    }");

            // --- 2. Request Record ---
            if (command.Description != null)
                sb.Append(FormatDoc(command.Description, 2, command.Parameters));

            if (command.Deprecated == true)
                sb.AppendLine("    [System.Obsolete(\"This command is deprecated.\", false)]");

            sb.AppendLine($"    [ChromeProtocol.Core.MethodName(\"{domainName}.{command.Name}\")]");
            sb.AppendLine($"    public record {reqName}(");
            GeneratePropertiesList(sb, command.Parameters, domainName, 3);
            sb.AppendLine($"    ) : ChromeProtocol.Core.ICommand<{resName}>");
            sb.AppendLine("    {");
            sb.AppendLine("    }");

            // --- 3. Result Record ---
            // Only generate doc comments for return properties
            if (command.Returns != null && command.Returns.Count > 0)
            {
                foreach (var ret in command.Returns)
                {
                    if (ret.Description != null)
                        sb.AppendLine($"    /// <param name=\"{ToPascalCase(ret.Name)}\">{SecurityElement.Escape(ret.Description.Replace("\n", ""))}</param>");
                }
            }

            sb.AppendLine($"    public record {resName}(");
            GeneratePropertiesList(sb, command.Returns, domainName, 3);
            sb.AppendLine($"    ) : ChromeProtocol.Core.IType");
            sb.AppendLine("    {");
            sb.AppendLine("    }");
        }

        protected static void GenerateEvent(StringBuilder sb, Event @event, string domainName)
        {
            if (@event.Description != null)
                sb.Append(FormatDoc(@event.Description, 2, @event.Parameters));

            if (@event.Deprecated == true)
                sb.AppendLine("    [System.Obsolete(\"This event is deprecated.\", false)]");

            sb.AppendLine($"    [ChromeProtocol.Core.MethodName(\"{domainName}.{@event.Name}\")]");
            sb.AppendLine($"    public record {ToPascalCase(@event.Name)}(");
            GeneratePropertiesList(sb, @event.Parameters, domainName, 3);
            sb.AppendLine("    ) : ChromeProtocol.Core.IEvent");
            sb.AppendLine("    {");
            sb.AppendLine("    }");
        }

        protected static void GeneratePropertiesList(StringBuilder sb, List<Property> properties, string domainName, int indentLevel)
        {
            if (properties == null || properties.Count == 0)
                return;

            var indent = new string(' ', indentLevel * 2);
            for (int i = 0; i < properties.Count; i++)
            {
                var prop = properties[i];
                var csharpType = GetCSharpType(prop.Type, prop.Ref, prop.Items, domainName);

                var isOptional = prop.Optional == true;
                var typeStr = isOptional ? $"{csharpType}?" : csharpType;
                var defaultStr = isOptional ? " = default" : "";
                var comma = (i < properties.Count - 1) ? "," : "";

                if (prop.Deprecated == true)
                    sb.AppendLine($"{indent}[property: System.Obsolete(\"This property marked as deprecated in the corresponding CDP definition schema. It may be removed in the future releases.\", false)]");

                sb.AppendLine($"{indent}[property: System.Text.Json.Serialization.JsonPropertyName(\"{prop.Name}\")]");
                sb.AppendLine($"{indent}{typeStr} {EscapeKeyword(ToPascalCase(prop.Name))}{defaultStr}{comma}");
            }
        }
        protected static void GenerateParameters(StringBuilder sb, List<Property>? parameters, string domainName, int indentLevel, string enclosingTypeName)
        {
            if (parameters == null || parameters.Count == 0) return;

            var sortedParameters = parameters.OrderBy(p => p.Optional == true).ToList();

            var indent = new string(' ', indentLevel * 2);
            for (int i = 0; i < sortedParameters.Count; i++)
            {
                var property = sortedParameters[i];

                var csharpType = GetCSharpType(property.Type, property.Ref, property.Items, domainName);
                var isOptional = property.Optional == true;
                var typeStr = isOptional ? $"{csharpType}?" : csharpType;

                var propertyName = EscapeKeyword(ToPascalCase(property.Name));
                var comma = (i < sortedParameters.Count - 1) ? "," : "";

                GenerateParameter(sb, property, typeStr, propertyName, indent, comma);
            }
        }

        protected static void GenerateParameter(StringBuilder sb, Property parameter, string typeStr, string propertyName, string indent, string comma)
        {
            if (parameter.Deprecated == true)
            {
                sb.AppendLine($"{indent}[property: System.Obsolete(\"This property marked as deprecated in the corresponding CDP definition schema. It may be removed in the future releases.\", false)]");
            }

            sb.AppendLine($"{indent}[property: System.Text.Json.Serialization.JsonPropertyName(\"{parameter.Name}\")]");

            var defaultValue = (parameter.Optional == true) ? " = default" : "";

            sb.AppendLine($"{indent}{typeStr} {propertyName}{defaultValue}{comma}");
        }

        protected static string GetCSharpBaseType(TypeKind? type)
        {
            switch (type)
            {
                case TypeKind.Boolean: 
                    return "bool";
                case TypeKind.Integer: 
                    return "int";
                case TypeKind.Number: 
                    return "double";
                case TypeKind.String: 
                    return "string";
                case TypeKind.Any: 
                    return "System.Text.Json.Nodes.JsonNode";
                case TypeKind.Object: 
                    return "System.Text.Json.Nodes.JsonObject";
                default: return "string";
            }
        }

        protected static string GetCSharpType(TypeKind? type, string @ref, Items items, string domain)
        {
            if (items != null)
                return $"System.Collections.Generic.IReadOnlyList<{GetCSharpType(items.Type, items.Ref, null, domain)}>";
            else if (!string.IsNullOrEmpty(@ref))
                return @ref.Contains(".") ? $"ChromeProtocol.Domains.{@ref}Type" : $"ChromeProtocol.Domains.{domain}.{@ref}Type";
            return GetCSharpBaseType(type);
        }

        protected static string FormatDoc(string description, int indentLevel, List<Property>? parameters = null)
        {
            if (string.IsNullOrWhiteSpace(description)) 
                return "";

            var indent = new string(' ', indentLevel * 4);

            var sb = new StringBuilder();

            if (!string.IsNullOrWhiteSpace(description))
            {
                sb.AppendLine($"{indent}/// <summary>");
                var lines = description.Replace("\r\n", "\n").Split('\n');
                foreach (var line in lines)
                {
                    var safeLine = SecurityElement.Escape(line.Trim());
                    sb.AppendLine($"{indent}/// {safeLine}");
                }
                sb.AppendLine($"{indent}/// </summary>");
            }

            if (parameters != null)
            {
                foreach (var param in parameters)
                {
                    if (!string.IsNullOrWhiteSpace(param.Description))
                    {
                        var safeDesc = SecurityElement.Escape(param.Description.Replace("\n", "<br/>\n" + indent + "/// "));
                        sb.AppendLine($"{indent}/// <param name=\"{ToPascalCase(param.Name)}\">{safeDesc}</param>");
                    }
                }
            }

            return sb.ToString();
        }

        // ----- Utils -----
        protected static string ToPascalCase(string text)
        {
            if (string.IsNullOrEmpty(text))
                return text;
            return char.ToUpperInvariant(text[0]) + text.Substring(1);
        }

        protected static string EscapeKeyword(string name)
        {
            var keywords = new[]
                { "abstract", "as", "base", "bool", "break", "byte", "case", "catch", "char", "checked", "class", "const", "continue", "decimal", "default", "delegate", "do", "double", "else", "enum", "event", "explicit", "extern", "false", "finally", "fixed", "float", "for", "foreach", "goto", "if", "implicit", "in", "int", "interface", "internal", "is", "lock", "long", "namespace", "new", "null", "object", "operator", "out", "override", "params", "private", "protected", "public", "readonly", "ref", "return", "sbyte", "sealed", "short", "sizeof", "stackalloc", "static", "string", "struct", "switch", "this", "throw", "true", "try", "typeof", "uint", "ulong", "unchecked", "unsafe", "ushort", "using", "virtual", "void", "volatile", "while", "yield" };
            return keywords.Contains(name) ? $"@{name}" : name;
        }
        // ----- Utils -----
    }
}
