using Generator.Models;
using System.Security;
using System.Text;

namespace Generator
{
    public class CdpGenerator
    {
        public static string GenerateCode(Domain domain)
        {
            FixProtocolSpec(domain);

            return GenerateDomain(domain);
        }

        protected static void FixProtocolSpec(Domain domain)
        {
            //    Fixes following errors in the official CDP spec:
            // 1. DOM includes an erroneous $ref that refers to itself.
            // 2. Page includes an event with an extraneous backtick in the description.
            // 3. Network.Cookie.expires is optional because sometimes its value can be null.

            if (domain.Name == "DOM")
            {
                foreach (var command in domain.Commands)
                {
                    if (command.Name == "resolveNode")
                    {
                        // Patch 1
                        if (command.Parameters != null)
                            command.Parameters[1].Ref = "BackendNodeId";
                        break;
                    }
                }
            }
            else if (domain.Name == "Page")
            {
                foreach (var @event in domain.Events)
                {
                    if (@event.Name == "screencastVisibilityChanged")
                    {
                        // Patch 2
                        if (@event.Description != null)
                            @event.Description = @event.Description.Replace("`", "");
                        break;
                    }
                }
            }
            else if (domain.Name == "Network")
            {
                foreach (var type in domain.Types)
                {
                    if (type.Id == "Cookie")
                    {
                        foreach (var prop in type.Properties)
                        {
                            if (prop.Name == "expires")
                            {
                                prop.Optional = true;
                                break;
                            }
                        }
                    }
                }
            }
        }

        protected static string GenerateDomain(Domain domain)
        {
            var indentLevel = 1;
            var indent = new string(' ', indentLevel * 4);

            var domainName = ToFirstUpper(domain.Name);

            var sb = new StringBuilder();
            var @namespace = "NoDriver.Cdp";

            sb.AppendLine("// <auto-generated />");
            sb.AppendLine("#nullable enable");
            sb.AppendLine("using System;");
            sb.AppendLine("using System.Collections.Generic;");
            sb.AppendLine("using System.Text.Json.Serialization;");
            sb.AppendLine("using System.Text.Json.Nodes;");
            sb.AppendLine();
            sb.AppendLine($"namespace {@namespace}");
            sb.AppendLine("{");

            if (domain.Deprecated == true)
                sb.AppendLine($"{indent}[Obsolete]");

            sb.AppendLine($"{indent}public static partial class {domainName}");
            sb.AppendLine($"{indent}{{");

            foreach (var type in domain.Types)
            {
                GenerateType(sb, type, domainName, indentLevel + 1);
            }

            foreach (var command in domain.Commands)
            {
                GenerateCommand(sb, command, domainName, indentLevel + 1);
            }

            foreach (var @event in domain.Events)
            {
                GenerateEvent(sb, @event, domainName, indentLevel + 1);
            }

            sb.AppendLine($"{indent}}}");
            sb.AppendLine("}");

            return sb.ToString();
        }

        protected static void GenerateType(StringBuilder sb, Models.Type type, string domainName, int indentLevel)
        {
            var indent = new string(' ', indentLevel * 4);

            var typeName = ToFirstUpper(type.Id);

            GenerateDoc(sb, type.Description, type.Properties, indentLevel);

            // 不是 Object 也不是 Array 的型別，也就是字串、整數、布林值等基本型別
            if (type.Kind != TypeKind.Object && type.Kind != TypeKind.Array)
            {
                var csharpType = GetCSharpType(type.Kind, null, null, domainName);
                sb.AppendLine($"{indent}[JsonConverter(typeof(PrimitiveTypeConverter))]");
                sb.AppendLine($"{indent}public record {typeName}(");
                sb.AppendLine($"{indent}    {csharpType} value");
                sb.AppendLine($"{indent}) : PrimitiveType<{csharpType}>(value)");
                sb.AppendLine($"{indent}{{");
                sb.AppendLine($"{indent}}}");
            }
            // 型別是陣列 Array
            else if (type.Kind == TypeKind.Array)
            {
                var csharpType = GetCSharpType(type.Kind, null, type.Items, domainName);
                sb.AppendLine($"{indent}[System.Text.Json.Serialization.JsonConverter(typeof(ChromeProtocol.Core.ArrayTypeConverter))]");
                sb.AppendLine($"{indent}public record {typeName}(");
                sb.AppendLine($"{indent}    IReadOnlyCollection<{csharpType}> items");
                sb.AppendLine($"{indent})");
                sb.AppendLine($"{indent}{{");
                sb.AppendLine($"{indent}}}");
            }
            // 型別是 Object，但沒有定義任何屬性
            else if (type.Kind == TypeKind.Object && type.Properties.Count == 0)
            {
                sb.AppendLine($"{indent}[System.Text.Json.Serialization.JsonConverter(typeof(ChromeProtocol.Core.ObjectTypeConverter))]");
                sb.AppendLine($"{indent}public record {typeName}(");
                sb.AppendLine($"{indent}    IReadOnlyDictionary<string, JsonNode?> properties");
                sb.AppendLine($"{indent})");
                sb.AppendLine($"{indent}{{");
                sb.AppendLine($"{indent}}}");
            }
            // 有定義具體屬性的物件 TypeKind.Object 且 Properties.Length > 0
            else
            {
                sb.AppendLine($"{indent}public record {typeName}(");
                GenerateParameters(sb, type.Properties, domainName, indentLevel + 1);
                sb.AppendLine($"{indent})");
                sb.AppendLine($"{indent}{{");
                sb.AppendLine($"{indent}}}");
            }
        }

        protected static void GenerateCommand(StringBuilder sb, Command command, string domainName, int indentLevel)
        {
            var indent = new string(' ', indentLevel * 4);

            var methodName = ToFirstUpper(command.Name);
            var reqName = $"{methodName}Request";
            var resName = $"{reqName}Result";

            // static Method
            {
                GenerateDoc(sb, command.Description, command.Parameters, indentLevel);

                if (command.Deprecated == true)
                    sb.AppendLine($"{indent}[Obsolete]");

                var methodArgs = new List<string>();
                var constructorArgs = new List<string>();

                foreach (var param in command.Parameters)
                {
                    var paramName = EscapeKeyword(ToFirstLower(param.Name));

                    var csharpType = GetCSharpType(param.Type, param.Ref, param.Items, domainName);

                    var arg = $"{csharpType} {paramName}";
                    if (param.Optional == true)
                        arg = $"{csharpType}? {paramName} = default";

                    methodArgs.Add(arg);
                    constructorArgs.Add(paramName);
                }

                sb.AppendLine($"{indent}public static {domainName}.{reqName} {methodName}({string.Join(", ", methodArgs)})");
                sb.AppendLine($"{indent}{{");
                sb.AppendLine($"{indent}    return new {domainName}.{reqName}({string.Join(", ", constructorArgs)});");
                sb.AppendLine($"{indent}}}");
            }

            // Request record
            {
                GenerateDoc(sb, command.Description, command.Parameters, indentLevel);

                if (command.Deprecated == true)
                    sb.AppendLine($"{indent}[Obsolete]");

                var newLine = "";
                if (command.Parameters.Count > 0)
                    newLine = Environment.NewLine;

                sb.AppendLine($"{indent}[MethodName(\"{domainName}.{command.Name}\")]");
                sb.Append($"{indent}public record {reqName}({newLine}");
                GenerateParameters(sb, command.Parameters, domainName, indentLevel + 1);
                sb.AppendLine($"{(newLine == "" ? "" : indent)})");
                sb.AppendLine($"{indent}{{");
                sb.AppendLine($"{indent}}}");
            }

            // Result record
            {
                GenerateDoc(sb, command.Description, command.Returns, indentLevel);

                if (command.Deprecated == true)
                    sb.AppendLine($"{indent}[Obsolete]");

                var newLine = "";
                if (command.Returns.Count > 0)
                    newLine = Environment.NewLine;

                sb.Append($"{indent}public record {resName}({newLine}");
                GenerateParameters(sb, command.Returns, domainName, indentLevel + 1);
                sb.AppendLine($"{(newLine == "" ? "" : indent)})");
                sb.AppendLine($"{indent}{{");
                sb.AppendLine($"{indent}}}");
            }
        }

        protected static void GenerateEvent(StringBuilder sb, Event @event, string domainName, int indentLevel)
        {
            var indent = new string(' ', indentLevel * 4);

            var eventName = ToFirstUpper(@event.Name);

            GenerateDoc(sb, @event.Description, @event.Parameters, indentLevel);

            if (@event.Deprecated == true)
                sb.AppendLine($"{indent}[Obsolete]");

            sb.AppendLine($"{indent}[MethodName(\"{domainName}.{eventName}\")]");
            sb.AppendLine($"{indent}public record {eventName}(");
            GenerateParameters(sb, @event.Parameters, domainName, indentLevel + 1);
            sb.AppendLine($"{indent})");
            sb.AppendLine($"{indent}{{");
            sb.AppendLine($"{indent}}}");
        }

        protected static void GenerateParameters(StringBuilder sb, List<Property> parameters, string domainName, int indentLevel)
        {
            var indent = new string(' ', indentLevel * 4);

            parameters = parameters.OrderBy(p => p.Optional == true).ToList();

            var index = 0;
            foreach (var param in parameters)
            {
                var paramName = EscapeKeyword(ToFirstLower(param.Name));

                var csharpType = GetCSharpType(param.Type, param.Ref, param.Items, domainName);

                var arg = $"{csharpType} {paramName}";
                if (param.Optional == true)
                    arg = $"{csharpType}? {paramName} = default";

                var comma = "";
                if (index < parameters.Count - 1)
                    comma = ",";

                sb.AppendLine($"{indent}{arg}{comma}");
                index++;
            }
        }

        protected static void GenerateDoc(StringBuilder sb, string? description, List<Property> parameters, int indentLevel)
        {
            var indent = new string(' ', indentLevel * 4);

            if (!string.IsNullOrWhiteSpace(description))
            {
                sb.AppendLine($"{indent}/// <summary>");
                var safeDesc = SecurityElement.Escape(description.Trim())
                    .Replace("\r\n", "\n")
                    .Replace("\n", $"<br/>{Environment.NewLine}{indent}/// ");
                sb.AppendLine($"{indent}/// {safeDesc}");
                sb.AppendLine($"{indent}/// </summary>");
            }

            foreach (var param in parameters)
            {
                if (!string.IsNullOrWhiteSpace(param.Description))
                {
                    var paramName = ToFirstLower(param.Name);

                    var safeDesc = SecurityElement.Escape(param.Description.Trim())
                        .Replace("\r\n", "\n")
                        .Replace("\n", $"<br/>{Environment.NewLine}{indent}/// ");
                    sb.AppendLine($"{indent}/// <param name=\"{paramName}\">{safeDesc}</param>");
                }
            }
        }

        protected static string GetCSharpType(TypeKind? type, string? @ref, Items? items, string domainName)
        {
            if (type == TypeKind.Boolean)
                return "bool";
            if (type == TypeKind.Integer)
                return "int";
            if (type == TypeKind.Number)
                return "double";
            if (type == TypeKind.String)
                return "string";
            if (type == TypeKind.Array)
            {
                if (items != null)
                    return $"IReadOnlyList<{GetCSharpType(items.Type, items.Ref, null, domainName)}>";
            }
            if (type == TypeKind.Object)
            {
                if (string.IsNullOrEmpty(@ref))
                    return "JsonObject";
                
            }
            if (type == TypeKind.Any)
            {
                if (string.IsNullOrEmpty(@ref))
                    return "JsonNode";
            }
            if (!string.IsNullOrEmpty(@ref))
                return @ref.Contains(".") ? $"{@ref}" : $"{domainName}.{@ref}";

            throw new ArgumentOutOfRangeException($"({nameof(type)}, {nameof(@ref)})");
        }

        // ----- Utils -----
        protected static string ToFirstUpper(string text)
        {
            if (string.IsNullOrEmpty(text))
                return text;
            return char.ToUpperInvariant(text[0]) + text.Substring(1);
        }

        protected static string ToFirstLower(string text)
        {
            if (string.IsNullOrEmpty(text))
                return text;
            return char.ToLowerInvariant(text[0]) + text.Substring(1);
        }

        protected static string EscapeKeyword(string name)
        {
            var keywords = new[]
                { "abstract", "as", "base", "bool", "break", "byte", "case", "catch", "char", "checked", "class", "const", "continue", "decimal", "default", "delegate", "do", "double", "else", "enum", "event", "explicit", "extern", "false", "finally", "fixed", "float", "for", "foreach", "goto", "if", "implicit", "in", "int", "interface", "internal", "is", "lock", "long", "namespace", "new", "null", "object", "operator", "out", "override", "params", "private", "protected", "public", "readonly", "ref", "return", "sbyte", "sealed", "short", "sizeof", "stackalloc", "static", "string", "struct", "switch", "this", "throw", "true", "try", "typeof", "uint", "ulong", "unchecked", "unsafe", "ushort", "using", "virtual", "void", "volatile", "while", "yield" };
            return keywords.Contains(name) ? $"@{name}" : name;
        }
        // ----- Utils -----
    }
}
